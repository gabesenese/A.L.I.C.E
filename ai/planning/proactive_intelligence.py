"""
Proactive Intelligence Loop
============================
Background intelligence system that monitors context, generates insights,
and proactively surfaces help without being asked.

This is what makes Alice feel like Jarvis - always aware, always ready,
always one step ahead.
"""

import time
import threading
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import deque
import logging

logger = logging.getLogger(__name__)


@dataclass
class ProactiveInsight:
    """A proactive insight generated by Alice"""
    insight_id: str
    category: str
    priority: int
    message: str
    suggested_action: Optional[str] = None
    context: Dict[str, Any] = field(default_factory=dict)
    generated_at: float = field(default_factory=time.time)
    delivered: bool = False
    dismissed: bool = False


@dataclass
class ContextSnapshot:
    """Snapshot of current context"""
    timestamp: float
    time_of_day: str
    day_of_week: str
    active_goals: int
    pending_tasks: int
    user_state: str
    metadata: Dict[str, Any] = field(default_factory=dict)


class ProactiveIntelligence:
    """
    Proactive intelligence system that runs in the background.

    Monitors:
    - Time and schedule (upcoming events, deadlines)
    - Active goals and progress
    - User behavioral patterns
    - System state and resources
    - External context (weather, news, etc)

    Generates:
    - Timely reminders
    - Contextual suggestions
    - Progress updates
    - Anticipatory help
    - Efficiency insights
    """

    def __init__(
        self,
        check_interval: int = 60,
        insight_retention: int = 50
    ):
        self.check_interval = check_interval  # seconds between checks
        self.insight_retention = insight_retention

        # Thread control
        self.running = False
        self.thread: Optional[threading.Thread] = None
        self.lock = threading.Lock()

        # Generated insights
        self.insights: deque[ProactiveInsight] = deque(maxlen=insight_retention)
        self.insight_counter = 0

        # Context tracking
        self.last_check: Optional[float] = None
        self.context_history: List[ContextSnapshot] = []

        # External systems (will be injected)
        self.goal_system = None
        self.profile_engine = None
        self.context_manager = None

        # Callbacks for delivering insights
        self.insight_callbacks: List[Callable] = []

    def inject_dependencies(
        self,
        goal_system=None,
        profile_engine=None,
        context_manager=None
    ):
        """Inject external systems"""
        self.goal_system = goal_system
        self.profile_engine = profile_engine
        self.context_manager = context_manager

    def register_callback(self, callback: Callable):
        """Register a callback for delivering insights"""
        self.insight_callbacks.append(callback)

    def start(self):
        """Start the proactive intelligence loop"""
        if self.running:
            logger.warning("Proactive intelligence already running")
            return

        self.running = True
        self.thread = threading.Thread(
            target=self._intelligence_loop,
            name="ProactiveIntelligence",
            daemon=True
        )
        self.thread.start()

        logger.info("Proactive intelligence loop started")

    def stop(self):
        """Stop the proactive intelligence loop"""
        self.running = False

        if self.thread:
            self.thread.join(timeout=5.0)

        logger.info("Proactive intelligence loop stopped")

    def _intelligence_loop(self):
        """Main intelligence loop running in background thread"""
        while self.running:
            try:
                self._perform_check()
                time.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"Error in proactive intelligence loop: {e}")
                time.sleep(self.check_interval)

    def _perform_check(self):
        """Perform a single proactive check"""
        self.last_check = time.time()

        # Capture context snapshot
        snapshot = self._capture_context()
        self.context_history.append(snapshot)

        # Limit history
        if len(self.context_history) > 100:
            self.context_history = self.context_history[-100:]

        # Run proactive checks
        self._check_time_based_insights(snapshot)
        self._check_goal_progress(snapshot)
        self._check_user_patterns(snapshot)
        self._check_system_state(snapshot)

    def _capture_context(self) -> ContextSnapshot:
        """Capture current context"""
        now = datetime.now()

        active_goals = 0
        if self.goal_system:
            active_goals = len(self.goal_system.get_active_goals())

        return ContextSnapshot(
            timestamp=time.time(),
            time_of_day=self._get_time_of_day(),
            day_of_week=now.strftime('%A'),
            active_goals=active_goals,
            pending_tasks=0,
            user_state='available'
        )

    def _get_time_of_day(self) -> str:
        """Get time of day category"""
        hour = datetime.now().hour

        if 5 <= hour < 9:
            return 'early_morning'
        elif 9 <= hour < 12:
            return 'morning'
        elif 12 <= hour < 14:
            return 'midday'
        elif 14 <= hour < 17:
            return 'afternoon'
        elif 17 <= hour < 21:
            return 'evening'
        elif 21 <= hour < 24:
            return 'night'
        else:
            return 'late_night'

    def _check_time_based_insights(self, snapshot: ContextSnapshot):
        """Generate time-based insights"""

        # Morning briefing
        if snapshot.time_of_day == 'early_morning':
            if not self._insight_exists_recently('morning_briefing', hours=12):
                self._generate_insight(
                    category='morning_briefing',
                    priority=2,
                    message="Good morning! Ready to start the day?",
                    suggested_action="Would you like a summary of your active goals?"
                )

        # End of day summary
        if snapshot.time_of_day == 'evening':
            if not self._insight_exists_recently('day_summary', hours=12):
                if snapshot.active_goals > 0:
                    self._generate_insight(
                        category='day_summary',
                        priority=3,
                        message=f"You have {snapshot.active_goals} active goals. Would you like an update?",
                        suggested_action="Ask 'show my goals' for progress"
                    )

    def _check_goal_progress(self, snapshot: ContextSnapshot):
        """Check goal progress and generate insights"""
        if not self.goal_system:
            return

        active_goals = self.goal_system.get_active_goals()

        for goal in active_goals:
            # Check for stalled goals
            time_since_update = time.time() - goal.updated_at
            hours_since_update = time_since_update / 3600.0

            if hours_since_update > 24 and goal.progress < 1.0:
                if not self._insight_exists_recently(f'stalled_goal_{goal.goal_id}', hours=24):
                    self._generate_insight(
                        category='stalled_goal',
                        priority=2,
                        message=f"Goal '{goal.title}' hasn't been updated in {int(hours_since_update)} hours",
                        suggested_action="Would you like to continue working on it?",
                        context={'goal_id': goal.goal_id}
                    )

            # Check for approaching deadlines
            if goal.deadline:
                time_until_deadline = goal.deadline - time.time()
                hours_remaining = time_until_deadline / 3600.0

                if 0 < hours_remaining < 24:
                    if not self._insight_exists_recently(f'deadline_approaching_{goal.goal_id}', hours=12):
                        self._generate_insight(
                            category='deadline_approaching',
                            priority=1,
                            message=f"Deadline for '{goal.title}' is in {int(hours_remaining)} hours!",
                            suggested_action=f"Current progress: {int(goal.progress * 100)}%",
                            context={'goal_id': goal.goal_id}
                        )

            # Check for blocked goals
            if goal.blockers:
                if not self._insight_exists_recently(f'blocked_goal_{goal.goal_id}', hours=6):
                    self._generate_insight(
                        category='blocked_goal',
                        priority=2,
                        message=f"Goal '{goal.title}' is blocked: {', '.join(goal.blockers)}",
                        suggested_action="Need help resolving this?",
                        context={'goal_id': goal.goal_id}
                    )

    def _check_user_patterns(self, snapshot: ContextSnapshot):
        """Check user behavioral patterns"""
        if not self.profile_engine or not self.profile_engine.profile:
            return

        # Get active patterns
        patterns = self.profile_engine.get_active_patterns(min_confidence=0.7)

        # Check for routine-based insights
        morning_pattern = any(p.pattern_id == 'morning_routine' for p in patterns)

        if morning_pattern and snapshot.time_of_day == 'early_morning':
            if not self._insight_exists_recently('morning_routine', hours=12):
                self._generate_insight(
                    category='routine_recognition',
                    priority=3,
                    message="I notice you're usually active in the morning. Need anything?",
                    suggested_action=None
                )

    def _check_system_state(self, snapshot: ContextSnapshot):
        """Check system state and resources"""
        # Could check:
        # - Disk space
        # - Memory usage
        # - Running processes
        # - Network connectivity
        # For now, placeholder for future expansion
        pass

    def _generate_insight(
        self,
        category: str,
        priority: int,
        message: str,
        suggested_action: Optional[str] = None,
        context: Dict[str, Any] = None
    ):
        """Generate and deliver a proactive insight"""
        self.insight_counter += 1

        insight = ProactiveInsight(
            insight_id=f"insight_{self.insight_counter}",
            category=category,
            priority=priority,
            message=message,
            suggested_action=suggested_action,
            context=context or {}
        )

        with self.lock:
            self.insights.append(insight)

        logger.info(f"Generated proactive insight: {category} - {message}")

        # Deliver insight via callbacks
        self._deliver_insight(insight)

    def _deliver_insight(self, insight: ProactiveInsight):
        """Deliver insight to registered callbacks"""
        for callback in self.insight_callbacks:
            try:
                callback(insight)
                insight.delivered = True
            except Exception as e:
                logger.error(f"Error delivering insight: {e}")

    def _insight_exists_recently(self, category: str, hours: float = 1.0) -> bool:
        """Check if an insight of this category was generated recently"""
        cutoff = time.time() - (hours * 3600)

        with self.lock:
            for insight in self.insights:
                if insight.category == category and insight.generated_at > cutoff:
                    return True

        return False

    def get_pending_insights(self, priority_threshold: int = 3) -> List[ProactiveInsight]:
        """Get pending insights above priority threshold"""
        with self.lock:
            return [
                insight for insight in self.insights
                if not insight.delivered and not insight.dismissed and insight.priority <= priority_threshold
            ]

    def dismiss_insight(self, insight_id: str):
        """Dismiss an insight"""
        with self.lock:
            for insight in self.insights:
                if insight.insight_id == insight_id:
                    insight.dismissed = True
                    break

    def get_stats(self) -> Dict[str, Any]:
        """Get proactive intelligence statistics"""
        with self.lock:
            total_insights = len(self.insights)
            delivered = sum(1 for i in self.insights if i.delivered)
            dismissed = sum(1 for i in self.insights if i.dismissed)
            pending = sum(1 for i in self.insights if not i.delivered and not i.dismissed)

        return {
            'running': self.running,
            'last_check': self.last_check,
            'total_insights': total_insights,
            'delivered': delivered,
            'dismissed': dismissed,
            'pending': pending,
            'check_interval_seconds': self.check_interval
        }

    def force_check(self):
        """Force an immediate proactive check"""
        if self.running:
            logger.info("Forcing proactive check")
            self._perform_check()


# Global singleton
_proactive_intelligence = None


def get_proactive_intelligence(check_interval: int = 60) -> ProactiveIntelligence:
    """Get or create global proactive intelligence instance"""
    global _proactive_intelligence
    if _proactive_intelligence is None:
        _proactive_intelligence = ProactiveIntelligence(check_interval=check_interval)
    return _proactive_intelligence
